---
title: "final_comp"
format:
  # pdf:
  #   number-sections: false
  html:
    code-fold: true
    theme: cosmo
    embed-resources: true
    number-sections: true
    math: true
    toc: true
    toc-depth: 4
    html-math-method: katex
    toc-location: left
execute: 
  cache: true
---

```{r setup}
library(WGCNA)
library(tidyverse)
library(randomForest)
library(mvtnorm)
library(fuzzyforest)
library(ranger)
library(future)
library(future.apply)
library(doFuture)
library(progressr)
library(here)
```


## **Load**

```{r}
source(here("./test/test.R"))
```

## n=100

```{r}
id <- 1
set.seed(id)

rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100, 1000)
n <- c(100)

param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")

param_settings
current_sim_params <- param_settings[ceiling((id)/rep_num), ]

sim_number <- 10
sim_results <- list()
sim_results_1 <- list()
sim_mod <- function(n, p, corr) {
  sigma <- matrix(corr, nrow = p, ncol = p)
  diag(sigma) <- 1
  X <- rmvnorm(n, sigma = sigma)
  return(X)
}

n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
  number_of_groups <- 4
  number_of_mods <- number_of_groups - 1
  p_per_group <- p/number_of_groups
  vim_list <- c(1:3, 76:78)
  vim_interest <- c(1:4, 76:79)
  beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
  number_of_groups <- 10
  number_of_mods <- number_of_groups - 1
  p_per_group <- p/number_of_groups
  vim_list <- c(1:3, 901:903)
  vim_interest <- c(1:4, 901:904)
  beta_list <- rep(c(5, 5, 2), 2)
}

registerDoSEQ()
set.seed(id)

all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
#mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction, 
                                mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction, 
                                mtry_factor = mtry_factor)
y <- as.numeric(y)
powers <- c(1:20)
sft <- pickSoftThreshold(X, powerVector = powers, verbose = 5)
softPower <- sft$powerEstimate
if (is.na(softPower)) softPower <- 3
net <- blockwiseModules(X,
                        power = softPower,
                        TOMType = "signed",
                        reassignThreshold = 0,
                        mergeCutHeight = 0.25,
                        numericLabels = TRUE,
                        pamRespectsDendro = FALSE,
                        verbose = 3)
moduleLabels <- net$colors
module_membership <- factor(moduleLabels)
```

### Run

```{r}
ff <- sf(X, y, module_membership = module_membership,
         select_params = select_params,
         shap_model = "full",
         screen_params = screen_params,
         auto_initial = 4,
         nodesize = 1,
         debug = 1,
         verbose = 1,
         initial = TRUE,
         num_processors = 8,
         min_features = 10,
         seed = id)

shap_feature <- data.frame(index = ff$final_SHAP[1], 
                           ff$final_SHAP[2], row.names = NULL)
vim <- shap_feature

ff_1 <- sf(X, y, module_membership = module_membership,
         select_params = select_params,
         shap_model = "full",
         screen_params = screen_params,
         auto_initial = 4,
         nodesize = 1,
         debug = 1,
         verbose = 1,
         initial = TRUE,
         num_processors = 1,
         min_features = 10,
         seed = id)

shap_feature_1 <- data.frame(index = ff_1$final_SHAP[1], 
                           ff_1$final_SHAP[2], row.names = NULL)
vim_1 <- shap_feature
```

## n=1000

```{r}
id <- 10000
set.seed(id)

rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100, 1000)
n <- c(100)

param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")

param_settings
current_sim_params <- param_settings[ceiling((id)/rep_num), ]

sim_number <- 10
sim_results <- list()
sim_results_1 <- list()
sim_mod <- function(n, p, corr) {
  sigma <- matrix(corr, nrow = p, ncol = p)
  diag(sigma) <- 1
  X <- rmvnorm(n, sigma = sigma)
  return(X)
}

n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
  number_of_groups <- 4
  number_of_mods <- number_of_groups - 1
  p_per_group <- p/number_of_groups
  vim_list <- c(1:3, 76:78)
  vim_interest <- c(1:4, 76:79)
  beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
  number_of_groups <- 10
  number_of_mods <- number_of_groups - 1
  p_per_group <- p/number_of_groups
  vim_list <- c(1:3, 901:903)
  vim_interest <- c(1:4, 901:904)
  beta_list <- rep(c(5, 5, 2), 2)
}

registerDoSEQ()
set.seed(id)

all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
#mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction, 
                                mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction, 
                                mtry_factor = mtry_factor)
y <- as.numeric(y)
powers <- c(1:20)
sft <- pickSoftThreshold(X, powerVector = powers, verbose = 5)
softPower <- sft$powerEstimate
if (is.na(softPower)) softPower <- 3
net <- blockwiseModules(X,
                        power = softPower,
                        TOMType = "signed",
                        reassignThreshold = 0,
                        mergeCutHeight = 0.25,
                        numericLabels = TRUE,
                        pamRespectsDendro = FALSE,
                        verbose = 3)
moduleLabels <- net$colors
module_membership <- factor(moduleLabels)
```

### Run

```{r}
ff_large <- sf(X, y, module_membership = module_membership,
         select_params = select_params,
         shap_model = "full",
         screen_params = screen_params,
         auto_initial = 4,
         nodesize = 1,
         debug = 1,
         verbose = 1,
         initial = TRUE,
         num_processors = 8,
         min_features = 10,
         seed = id)

shap_feature_large <- data.frame(index = ff_large$final_SHAP[1], 
                           ff_large$final_SHAP[2], row.names = NULL)

ff_1_large <- sf(X, y, module_membership = module_membership,
         select_params = select_params,
         shap_model = "full",
         screen_params = screen_params,
         auto_initial = 4,
         nodesize = 1,
         debug = 1,
         verbose = 1,
         initial = TRUE,
         num_processors = 1,
         min_features = 10,
         seed = id)

shap_feature_1_large <- data.frame(index = ff_1_large$final_SHAP[1], 
                           ff_1_large$final_SHAP[2], row.names = NULL)
```

## Comparison

```{r}
library(dplyr)
library(ggplot2)

# Helper to extract runtimes and add Total
extract_runtimes <- function(obj, label) {
  rt <- unlist(obj$runtimes)
  df <- data.frame(Method = label, Phase = names(rt), Time = rt)
  df <- rbind(df, data.frame(Method = label, Phase = "Total", Time = sum(rt)))
  return(df)
}

# Combine all into one dataframe
runtimes <- bind_rows(
  extract_runtimes(ff, "Parallel, n = 100"),
  extract_runtimes(ff_1, "Single, n = 100"),
  extract_runtimes(ff_large, "Parallel, n = 1000"),
  extract_runtimes(ff_1_large, "Single, n = 1000")
) %>%
  mutate(
    SampleSize = ifelse(grepl("1000", Method), "n = 1000", "n = 100"),
    RunType = ifelse(grepl("Single", Method), "Single", "Parallel"),
    Phase = factor(Phase, levels = c("Screen", "Selection", "Final_RF", "Total"))
  )

# Plot
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
  geom_point(aes(color = SampleSize, shape = RunType), size = 3) +
  geom_line(aes(color = SampleSize, linetype = RunType), linewidth = 1) +
  labs(
    title = "Shapley Forest Runtimes by Phase and Method",
    x = "Phase",
    y = "Time (seconds)",
    color = "Sample Size",
    shape = "Run Type",
    linetype = "Run Type"
  ) +
  scale_color_manual(values = c("n = 100" = "#1f77b4", "n = 1000" = "#2ca02c")) +
  theme_minimal()

```

```{r}
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
  geom_point(aes(color = RunType, shape = RunType), size = 3) +
  geom_line(aes(color = RunType, linetype = RunType), linewidth = 1) +
  facet_wrap(~ SampleSize) +
  labs(
    title = "Shapley Forest Runtimes by Phase, Faceted by Sample Size",
    x = "Phase",
    y = "Time (seconds)",
    color = "Run Type",
    shape = "Run Type",
    linetype = "Run Type"
  ) +
  scale_color_manual(values = c("Single" = "#1f77b4", "Parallel" = "#d62728")) +
  theme_minimal()
```

