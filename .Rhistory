current_sim_params,
runtime = list(ff$runtimes, ff_1$runtimes))
out
# Extract data
vim_df <- out[[1]]
vim_interest <- out[[2]]
# Filter and prepare
plot_data <- vim_df %>%
filter(gsub("V", "", feature) %in% as.character(vim_interest)) %>%
mutate(feature = factor(feature, levels = feature))
# Plot
ggplot(plot_data, aes(x = feature, y = selected_prop)) +
geom_col(fill = "steelblue") +
labs(title = "Selection Proportion for VIM-Interest Features",
x = "Feature",
y = "Selected Proportion") +
theme_minimal()
plot_data <- vim_df %>%
filter(gsub("V", "", feature) %in% as.character(vim_interest)) %>%
mutate(feature = factor(feature, levels = feature),
order = as.numeric(gsub("V", "", feature))) %>%
arrange(order)
# Plot with dots and connecting lines
ggplot(plot_data, aes(x = feature, y = selected_prop, group = 1)) +
geom_point(size = 3, color = "steelblue") +
geom_line(color = "steelblue", linewidth = 1) +
labs(title = "Selected Proportion for VIM-Interest Features",
x = "Feature",
y = "Selected Proportion") +
theme_minimal()
out
# Extract and filter Single (out[[1]] and out[[2]])
df_single <- out[[1]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[2]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "Single")
# Extract and filter Non Parallel (out[[3]] and out[[4]])
df_nonpar <- out[[3]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[4]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "Non Parallel")
# Combine
plot_data <- bind_rows(df_single, df_nonpar) %>%
arrange(Label, feature_num) %>%
mutate(feature = factor(feature, levels = unique(feature_num)))
# Plot
ggplot(plot_data, aes(x = feature, y = selected_prop, color = Label, group = Label)) +
geom_point(size = 3) +
geom_line(linewidth = 1) +
labs(title = "Selected Proportion Comparison: Single vs Non Parallel",
x = "Feature",
y = "Selected Proportion",
color = "Run Type") +
theme_minimal()
df_single
# Extract and filter Non Parallel (out[[3]] and out[[4]])
df_par <- out[[3]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[4]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "parallel")
df_par
out[[3]]
out[[4]]
df_single <- out[[1]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[2]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "Single")
df_par <- out[[3]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[2]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "parallel")
# Combine
plot_data <- bind_rows(df_single, df_nonpar) %>%
arrange(Label, feature_num) %>%
mutate(feature = factor(feature, levels = unique(feature_num)))
# Plot
ggplot(plot_data, aes(x = feature, y = selected_prop, color = Label, group = Label)) +
geom_point(size = 3) +
geom_line(linewidth = 1) +
labs(title = "Selected Proportion Comparison: Single vs Non Parallel",
x = "Feature",
y = "Selected Proportion",
color = "Run Type") +
theme_minimal()
df_par
df_par <- out[[3]] %>%
filter(gsub("V", "", feature) %in% as.character(out[[2]])) %>%
mutate(feature_num = as.numeric(gsub("V", "", feature)),
Label = "Parallel")
# Combine
plot_data <- bind_rows(df_single, df_nonpar) %>%
arrange(Label, feature_num) %>%
mutate(feature = factor(feature, levels = unique(feature_num)))
# Combine
plot_data <- bind_rows(df_single, df_par) %>%
arrange(Label, feature_num) %>%
mutate(feature = factor(feature, levels = unique(feature_num)))
plot_data
# Combine
plot_data <- bind_rows(df_single, df_par) %>%
arrange(Label, feature_num) %>%
mutate(feature = factor(as.character(feature, levels = unique(feature_num))))
# Plot
ggplot(plot_data, aes(x = feature, y = selected_prop, color = Label, group = Label)) +
geom_point(size = 3) +
geom_line(linewidth = 1) +
labs(title = "Selected Proportion Comparison: Single vs Non Parallel",
x = "Feature",
y = "Selected Proportion",
color = "Run Type") +
theme_minimal()
library(WGCNA)
library(tidyverse)
library(randomForest)
library(mvtnorm)
library(fuzzyforest)
library(ranger)
library(future)
library(future.apply)
library(doFuture)
library(progressr)
library(WGCNA)
library(tidyverse)
library(randomForest)
library(mvtnorm)
library(fuzzyforest)
library(ranger)
library(future)
library(future.apply)
library(doFuture)
library(progressr)
source(here("./test/test.R"))
library(here)
source(here("./test/test.R"))
id <- 1
set.seed(id)
rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100, 1000)
n <- c(100)
param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")
param_settings
current_sim_params <- param_settings[ceiling((id)/rep_num), ]
sim_number <- 10
sim_results <- list()
sim_results_1 <- list()
sim_mod <- function(n, p, corr) {
sigma <- matrix(corr, nrow = p, ncol = p)
diag(sigma) <- 1
X <- rmvnorm(n, sigma = sigma)
return(X)
}
n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
number_of_groups <- 4
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 76:78)
vim_interest <- c(1:4, 76:79)
beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
registerDoSEQ()
set.seed(id)
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
#mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction,
mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction,
mtry_factor = mtry_factor)
y <- as.numeric(y)
powers <- c(1:20)
sft <- pickSoftThreshold(X, powerVector = powers, verbose = 5)
softPower <- sft$powerEstimate
if (is.na(softPower)) softPower <- 3
net <- blockwiseModules(X,
power = softPower,
TOMType = "signed",
reassignThreshold = 0,
mergeCutHeight = 0.25,
numericLabels = TRUE,
pamRespectsDendro = FALSE,
verbose = 3)
moduleLabels <- net$colors
module_membership <- factor(moduleLabels)
ff <- sf(X, y, module_membership = module_membership,
select_params = select_params,
shap_model = "full",
screen_params = screen_params,
auto_initial = 4,
nodesize = 1,
debug = 1,
verbose = 1,
initial = TRUE,
num_processors = 8,
min_features = 10,
seed = id)
shap_feature <- data.frame(index = ff$final_SHAP[1],
ff$final_SHAP[2], row.names = NULL)
vim <- shap_feature
sim_results[[l]] <- vim
vim
ff_1 <- sf(X, y, module_membership = module_membership,
select_params = select_params,
shap_model = "full",
screen_params = screen_params,
auto_initial = 4,
nodesize = 1,
debug = 1,
verbose = 1,
initial = TRUE,
num_processors = 1,
min_features = 10,
seed = id)
ff$runtimes
ff$final_SHAP
ff_1$runtimes
id <- 10000
set.seed(id)
rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100, 1000)
n <- c(100)
param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")
param_settings
current_sim_params <- param_settings[ceiling((id)/rep_num), ]
sim_number <- 10
sim_results <- list()
sim_results_1 <- list()
sim_mod <- function(n, p, corr) {
sigma <- matrix(corr, nrow = p, ncol = p)
diag(sigma) <- 1
X <- rmvnorm(n, sigma = sigma)
return(X)
}
n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
number_of_groups <- 4
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 76:78)
vim_interest <- c(1:4, 76:79)
beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
registerDoSEQ()
set.seed(id)
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
#mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction,
mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction,
mtry_factor = mtry_factor)
y <- as.numeric(y)
powers <- c(1:20)
sft <- pickSoftThreshold(X, powerVector = powers, verbose = 5)
softPower <- sft$powerEstimate
if (is.na(softPower)) softPower <- 3
net <- blockwiseModules(X,
power = softPower,
TOMType = "signed",
reassignThreshold = 0,
mergeCutHeight = 0.25,
numericLabels = TRUE,
pamRespectsDendro = FALSE,
verbose = 3)
moduleLabels <- net$colors
module_membership <- factor(moduleLabels)
ff_large <- sf(X, y, module_membership = module_membership,
select_params = select_params,
shap_model = "full",
screen_params = screen_params,
auto_initial = 4,
nodesize = 1,
debug = 1,
verbose = 1,
initial = TRUE,
num_processors = 8,
min_features = 10,
seed = id)
shap_feature_large <- data.frame(index = ff_large$final_SHAP[1],
ff_large$final_SHAP[2], row.names = NULL)
ff_1_large <- sf(X, y, module_membership = module_membership,
select_params = select_params,
shap_model = "full",
screen_params = screen_params,
auto_initial = 4,
nodesize = 1,
debug = 1,
verbose = 1,
initial = TRUE,
num_processors = 1,
min_features = 10,
seed = id)
shap_feature_1_large <- data.frame(index = ff_1_large$final_SHAP[1],
ff_1_large$final_SHAP[2], row.names = NULL)
# Collect runtimes into a data frame
runtimes <- bind_rows(
data.frame(Method = "Single, n = 100", Phase = names(ff$runtimes), Time = unlist(ff$runtimes)),
data.frame(Method = "Parallel, n = 100", Phase = names(ff_1$runtimes), Time = unlist(ff_1$runtimes)),
data.frame(Method = "Single, n = 1000", Phase = names(ff_large$runtimes), Time = unlist(ff_large$runtimes)),
data.frame(Method = "Parallel, n = 1000", Phase = names(ff_1_large$runtimes), Time = unlist(ff_1_large$runtimes))
)
ggplot(runtimes, aes(x = Phase, y = Time, group = Method, color = Method)) +
geom_point(size = 3) +
geom_line(linewidth = 1) +
labs(title = "Fuzzy Forest Runtimes by Phase and Method",
x = "Phase",
y = "Time (seconds)",
color = "Method") +
theme_minimal()
# Create a helper to extract runtimes and compute total
extract_runtimes <- function(obj, label) {
rt <- unlist(obj$runtimes)
df <- data.frame(Method = label, Phase = names(rt), Time = rt)
df <- rbind(df, data.frame(Method = label, Phase = "Total", Time = sum(rt)))
return(df)
}
# Combine all into one
runtimes <- bind_rows(
extract_runtimes(ff, "Single, n = 100"),
extract_runtimes(ff_1, "Parallel, n = 100"),
extract_runtimes(ff_large, "Single, n = 1000"),
extract_runtimes(ff_1_large, "Parallel, n = 1000")
)
# Add grouping variables for styling
runtimes <- runtimes %>%
mutate(
RunType = ifelse(grepl("Single", Method), "Single", "Parallel"),
SampleSize = ifelse(grepl("1000", Method), "1000", "100")
)
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = RunType, shape = SampleSize), size = 3) +
geom_line(aes(color = RunType, linetype = SampleSize), linewidth = 1) +
labs(
title = "Fuzzy Forest Runtimes by Phase and Method",
x = "Phase",
y = "Time (seconds)",
color = "Run Type",
shape = "Sample Size",
linetype = "Sample Size"
) +
scale_color_manual(values = c("Single" = "#1f77b4", "Parallel" = "#d62728")) +
theme_minimal()
# Add grouping variables for styling
runtimes <- runtimes %>%
mutate(
SampleSize = ifelse(grepl("1000", Method), "n = 1000", "n = 100"),
RunType = ifelse(grepl("Single", Method), "Single", "Parallel")
)
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = SampleSize, shape = RunType), size = 3) +
geom_line(aes(color = SampleSize, linetype = RunType), linewidth = 1) +
labs(
title = "Shapley Forest Runtimes by Phase and Method",
x = "Phase",
y = "Time (seconds)",
color = "Sample Size",
shape = "Run Type",
linetype = "Run Type"
) +
scale_color_manual(values = c("n = 100" = "#1f77b4", "n = 1000" = "#2ca02c")) +
theme_minimal()
library(dplyr)
library(ggplot2)
# Helper to extract runtimes and add Total
extract_runtimes <- function(obj, label) {
rt <- unlist(obj$runtimes)
df <- data.frame(Method = label, Phase = names(rt), Time = rt)
df <- rbind(df, data.frame(Method = label, Phase = "Total", Time = sum(rt)))
return(df)
}
# Combine all into one dataframe
runtimes <- bind_rows(
extract_runtimes(ff, "Single, n = 100"),
extract_runtimes(ff_1, "Parallel, n = 100"),
extract_runtimes(ff_large, "Single, n = 1000"),
extract_runtimes(ff_1_large, "Parallel, n = 1000")
) %>%
mutate(
SampleSize = ifelse(grepl("1000", Method), "n = 1000", "n = 100"),
RunType = ifelse(grepl("Single", Method), "Single", "Parallel"),
Phase = factor(Phase, levels = c("Screen", "Selection", "Final_RF", "Total"))
)
# Plot
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = SampleSize, shape = RunType), size = 3) +
geom_line(aes(color = SampleSize, linetype = RunType), linewidth = 1) +
labs(
title = "Fuzzy Forest Runtimes by Phase and Method",
x = "Phase",
y = "Time (seconds)",
color = "Sample Size",
shape = "Run Type",
linetype = "Run Type"
) +
scale_color_manual(values = c("n = 100" = "#1f77b4", "n = 1000" = "#2ca02c")) +
theme_minimal()
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = RunType, shape = RunType), size = 3) +
geom_line(aes(color = RunType, linetype = RunType), linewidth = 1) +
facet_wrap(~ SampleSize) +
labs(
title = "Fuzzy Forest Runtimes by Phase, Faceted by Sample Size",
x = "Phase",
y = "Time (seconds)",
color = "Run Type",
shape = "Run Type",
linetype = "Run Type"
) +
scale_color_manual(values = c("Single" = "#1f77b4", "Parallel" = "#d62728")) +
theme_minimal()
ff$runtimes
ff_1$runtimes
runtimes
library(dplyr)
library(ggplot2)
# Helper to extract runtimes and add Total
extract_runtimes <- function(obj, label) {
rt <- unlist(obj$runtimes)
df <- data.frame(Method = label, Phase = names(rt), Time = rt)
df <- rbind(df, data.frame(Method = label, Phase = "Total", Time = sum(rt)))
return(df)
}
# Combine all into one dataframe
runtimes <- bind_rows(
extract_runtimes(ff, "Parallel, n = 100"),
extract_runtimes(ff_1, "Single, n = 100"),
extract_runtimes(ff_large, "Parallel, n = 1000"),
extract_runtimes(ff_1_large, "Single, n = 1000")
) %>%
mutate(
SampleSize = ifelse(grepl("1000", Method), "n = 1000", "n = 100"),
RunType = ifelse(grepl("Single", Method), "Single", "Parallel"),
Phase = factor(Phase, levels = c("Screen", "Selection", "Final_RF", "Total"))
)
# Plot
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = SampleSize, shape = RunType), size = 3) +
geom_line(aes(color = SampleSize, linetype = RunType), linewidth = 1) +
labs(
title = "Fuzzy Forest Runtimes by Phase and Method",
x = "Phase",
y = "Time (seconds)",
color = "Sample Size",
shape = "Run Type",
linetype = "Run Type"
) +
scale_color_manual(values = c("n = 100" = "#1f77b4", "n = 1000" = "#2ca02c")) +
theme_minimal()
ggplot(runtimes, aes(x = Phase, y = Time, group = Method)) +
geom_point(aes(color = RunType, shape = RunType), size = 3) +
geom_line(aes(color = RunType, linetype = RunType), linewidth = 1) +
facet_wrap(~ SampleSize) +
labs(
title = "Fuzzy Forest Runtimes by Phase, Faceted by Sample Size",
x = "Phase",
y = "Time (seconds)",
color = "Run Type",
shape = "Run Type",
linetype = "Run Type"
) +
scale_color_manual(values = c("Single" = "#1f77b4", "Parallel" = "#d62728")) +
theme_minimal()
